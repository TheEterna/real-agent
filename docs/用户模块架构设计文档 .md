# 用户模块架构设计文档

## 一、架构定位

### 1.1 模块定位

用户模块作为 **基础设施层（Infrastructure Layer）** 存在，为整个系统提供：
- 用户身份认证（Authentication）
- 用户信息管理（User Management）
- 会话管理（Session Management）
- 用户上下文传递（User Context Propagation）

### 1.2 设计原则

1. **非侵入性**：不强制其他模块依赖用户模块
2. **可选性**：支持匿名访问和认证访问两种模式
3. **轻量级**：避免过度设计，保持简单实用
4. **响应式**：完全兼容 WebFlux 响应式架构

---

## 二、模块结构设计

### 2.1 目录结构

```
real-agent-domain/
├── entity/
│   └── user/
│       └── User.java                    # 用户实体
└── repository/
    └── user/
        └── UserRepository.java          # 用户数据访问

real-agent-application/
├── service/
│   └── user/
│       ├── UserService.java             # 用户业务服务
│       ├── AuthService.java             # 认证服务
│       └── TokenService.java            # Token 服务
└── dto/
    └── user/
        ├── LoginRequest.java            # 登录请求
        ├── LoginResponse.java           # 登录响应
        ├── UserInfoDTO.java             # 用户信息 DTO
        └── RegisterRequest.java         # 注册请求

real-agent-web/
├── controller/
│   └── user/
│       ├── AuthController.java          # 认证控制器
│       └── UserController.java          # 用户信息控制器
├── filter/
│   └── AuthenticationFilter.java        # 认证过滤器
├── context/
│   └── UserContextHolder.java           # 用户上下文持有者
└── config/
    └── AuthConfig.java                  # 认证配置

real-agent-common/
└── util/
    ├── JwtUtil.java                     # JWT 工具类
    └── PasswordUtil.java                # 密码加密工具
```

### 2.2 模块依赖关系

```
real-agent-web (接入层)
    ↓ 依赖
real-agent-application (应用层)
    ↓ 依赖
real-agent-domain (领域层)
    ↓ 依赖
real-agent-contract (契约层)
```

---

## 三、核心组件设计

### 3.1 认证流程

#### 登录流程
```
用户登录请求
    ↓
AuthController.login()
    ↓
AuthService.authenticate()
    ↓
UserRepository.findByExternalId()
    ↓
验证密码
    ↓
TokenService.generateToken()
    ↓
返回 JWT Token
```

#### 请求认证流程
```
HTTP 请求
    ↓
AuthenticationFilter
    ↓
提取 Token
    ↓
TokenService.validateToken()
    ↓
解析用户信息
    ↓
UserContextHolder.setUser()
    ↓
继续处理请求
    ↓
UserContextHolder.clear()
```

### 3.2 用户上下文管理

#### UserContext 设计
```java
public class UserContext {
    private Long userId;
    private String externalId;
    private String nickname;
    private Map<String, Object> attributes;
    
    // 便捷方法
    public boolean isAuthenticated() {
        return userId != null;
    }
    
    public boolean isAnonymous() {
        return userId == null;
    }
}
```

#### UserContextHolder 设计（响应式）
```java
public class UserContextHolder {
    private static final String USER_CONTEXT_KEY = "USER_CONTEXT";
    
    // 设置用户上下文到 Reactor Context
    public static Context setUser(Context context, UserContext user) {
        return context.put(USER_CONTEXT_KEY, user);
    }
    
    // 从 Reactor Context 获取用户上下文
    public static Mono<UserContext> getUser() {
        return Mono.deferContextual(ctx -> 
            Mono.justOrEmpty(ctx.getOrEmpty(USER_CONTEXT_KEY))
        );
    }
    
    // 获取用户 ID
    public static Mono<Long> getUserId() {
        return getUser().map(UserContext::getUserId);
    }
}
```

### 3.3 JWT Token 设计

#### Token 结构
```json
{
  "header": {
    "alg": "HS256",
    "typ": "JWT"
  },
  "payload": {
    "userId": 123,
    "externalId": "user_001",
    "nickname": "张三",
    "exp": 1735689600,
    "iat": 1735603200
  },
  "signature": "..."
}
```

#### Token 类型
1. **Access Token**：短期有效（2小时），用于 API 访问
2. **Refresh Token**：长期有效（7天），用于刷新 Access Token

---

## 四、与其他模块的集成方式

### 4.1 集成模式：可选依赖

#### 模式一：匿名访问（无需认证）
```java
@GetMapping("/api/public/roles")
public Flux<RoleDTO> getPublicRoles() {
    // 直接访问，无需用户信息
    return roleService.findActiveRoles();
}
```

#### 模式二：可选认证（支持匿名和认证）
```java
@GetMapping("/api/sessions")
public Flux<SessionDTO> getSessions() {
    return UserContextHolder.getUserId()
        .flatMapMany(userId -> sessionService.findByUserId(userId))
        .switchIfEmpty(sessionService.findPublicSessions());
}
```

#### 模式三：强制认证（必须登录）
```java
@GetMapping("/api/user/sessions")
public Flux<SessionDTO> getUserSessions() {
    return UserContextHolder.getUserId()
        .flatMapMany(userId -> sessionService.findByUserId(userId))
        .switchIfEmpty(Mono.error(new UnauthorizedException("请先登录")));
}
```

### 4.2 Agent 模块集成

#### AgentContext 扩展
```java
public class AgentContext {
    private String sessionId;
    private String turnId;
    private LocalDateTime startTime;
    
    // 新增：用户信息（可选）
    private Long userId;  // 可为 null
    private String userExternalId;
    
    // 判断是否有用户上下文
    public boolean hasUser() {
        return userId != null;
    }
}
```

#### Agent 执行时注入用户信息
```java
public Flux<AgentExecutionEvent> executeReAct(String message, String sessionId) {
    return UserContextHolder.getUserId()
        .defaultIfEmpty(-1L)  // 匿名用户使用 -1
        .flatMapMany(userId -> {
            AgentContext context = new AgentContext()
                .setSessionId(sessionId)
                .setUserId(userId);
            
            return reActStrategy.execute(message, context);
        });
}
```

### 4.3 数据隔离策略

#### 策略一：用户数据隔离
```java
// 查询用户自己的会话
@Query("SELECT * FROM playground.roleplay_sessions WHERE user_id = :userId")
Flux<PlaygroundRoleplaySession> findByUserId(Long userId);
```

#### 策略二：公共数据共享
```java
// 查询所有公开角色（不区分用户）
@Query("SELECT * FROM playground.roleplay_roles WHERE status = 1")
Flux<PlaygroundRoleplayRole> findActiveRoles();
```

#### 策略三：混合模式
```java
public Flux<SessionDTO> findSessions() {
    return UserContextHolder.getUserId()
        .flatMapMany(userId -> 
            // 已登录：返回用户会话 + 公共会话
            sessionRepository.findByUserId(userId)
                .concatWith(sessionRepository.findPublicSessions())
        )
        .switchIfEmpty(
            // 未登录：只返回公共会话
            sessionRepository.findPublicSessions()
        );
}
```

---

## 五、API 接口设计

### 5.1 认证接口

#### 登录
```http
POST /api/auth/login
Content-Type: application/json

{
  "externalId": "user_001",
  "password": "encrypted_password"
}

Response:
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIs...",
    "expiresIn": 7200,
    "user": {
      "userId": 123,
      "externalId": "user_001",
      "nickname": "张三",
      "avatarUrl": "https://..."
    }
  }
}
```

#### 注册
```http
POST /api/auth/register
Content-Type: application/json

{
  "externalId": "user_001",
  "password": "encrypted_password",
  "nickname": "张三",
  "avatarUrl": "https://..."
}

Response:
{
  "success": true,
  "data": {
    "userId": 123,
    "externalId": "user_001"
  }
}
```

#### 刷新 Token
```http
POST /api/auth/refresh
Content-Type: application/json

{
  "refreshToken": "eyJhbGciOiJIUzI1NiIs..."
}

Response:
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIs...",
    "expiresIn": 7200
  }
}
```

#### 登出
```http
POST /api/auth/logout
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

Response:
{
  "success": true,
  "message": "登出成功"
}
```

### 5.2 用户信息接口

#### 获取当前用户信息
```http
GET /api/user/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

Response:
{
  "success": true,
  "data": {
    "userId": 123,
    "externalId": "user_001",
    "nickname": "张三",
    "avatarUrl": "https://...",
    "createdAt": "2025-01-01 10:00:00"
  }
}
```

#### 更新用户信息
```http
PUT /api/user/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json

{
  "nickname": "李四",
  "avatarUrl": "https://..."
}

Response:
{
  "success": true,
  "data": {
    "userId": 123,
    "nickname": "李四",
    "avatarUrl": "https://..."
  }
}
```

---

## 六、前端集成方案

### 6.1 Token 存储

#### LocalStorage 方案
```javascript
// 登录成功后存储
localStorage.setItem('accessToken', response.data.accessToken)
localStorage.setItem('refreshToken', response.data.refreshToken)

// 请求时携带
axios.defaults.headers.common['Authorization'] = `Bearer ${localStorage.getItem('accessToken')}`
```

#### Vuex/Pinia 状态管理
```javascript
// stores/auth.ts
export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    accessToken: null,
    refreshToken: null
  }),
  
  actions: {
    async login(credentials) {
      const response = await authApi.login(credentials)
      this.user = response.data.user
      this.accessToken = response.data.accessToken
      this.refreshToken = response.data.refreshToken
      
      // 持久化
      localStorage.setItem('accessToken', this.accessToken)
      localStorage.setItem('refreshToken', this.refreshToken)
    },
    
    async logout() {
      await authApi.logout()
      this.user = null
      this.accessToken = null
      this.refreshToken = null
      localStorage.clear()
    }
  },
  
  getters: {
    isAuthenticated: (state) => !!state.accessToken
  }
})
```

### 6.2 Axios 拦截器

#### 请求拦截器（自动添加 Token）
```javascript
axios.interceptors.request.use(
  config => {
    const token = localStorage.getItem('accessToken')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  error => Promise.reject(error)
)
```

#### 响应拦截器（自动刷新 Token）
```javascript
axios.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config
    
    // Token 过期，尝试刷新
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true
      
      try {
        const refreshToken = localStorage.getItem('refreshToken')
        const response = await authApi.refresh({ refreshToken })
        
        const newAccessToken = response.data.accessToken
        localStorage.setItem('accessToken', newAccessToken)
        
        // 重试原请求
        originalRequest.headers.Authorization = `Bearer ${newAccessToken}`
        return axios(originalRequest)
      } catch (refreshError) {
        // 刷新失败，跳转登录页
        router.push('/login')
        return Promise.reject(refreshError)
      }
    }
    
    return Promise.reject(error)
  }
)
```

### 6.3 路由守卫

```javascript
// router/index.ts
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore()
  
  // 需要认证的路由
  if (to.meta.requiresAuth && !authStore.isAuthenticated) {
    next('/login')
  }
  // 已登录用户访问登录页，重定向到首页
  else if (to.path === '/login' && authStore.isAuthenticated) {
    next('/')
  }
  else {
    next()
  }
})
```

---

## 七、数据库设计

### 7.1 用户表（已存在）

```sql
CREATE TABLE app_user.users (
    id BIGSERIAL PRIMARY KEY,
    external_id VARCHAR(255) UNIQUE NOT NULL,  -- 外部 ID（登录账号）
    password_hash VARCHAR(255),                 -- 密码哈希（可选，支持第三方登录）
    nickname VARCHAR(100),                      -- 昵称
    avatar_url VARCHAR(500),                    -- 头像 URL
    status INTEGER DEFAULT 1,                   -- 状态：1-正常，0-禁用
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 索引
CREATE INDEX idx_users_external_id ON app_user.users(external_id);
CREATE INDEX idx_users_status ON app_user.users(status);
```

### 7.2 Token 黑名单表（可选）

```sql
CREATE TABLE app_user.token_blacklist (
    id BIGSERIAL PRIMARY KEY,
    token_hash VARCHAR(255) UNIQUE NOT NULL,   -- Token 哈希
    user_id BIGINT NOT NULL,                   -- 用户 ID
    expires_at TIMESTAMP NOT NULL,             -- 过期时间
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES app_user.users(id)
);

-- 索引
CREATE INDEX idx_token_blacklist_hash ON app_user.token_blacklist(token_hash);
CREATE INDEX idx_token_blacklist_expires ON app_user.token_blacklist(expires_at);
```

### 7.3 用户会话表（可选，用于多设备管理）

```sql
CREATE TABLE app_user.user_sessions (
    id BIGSERIAL PRIMARY KEY,
    user_id BIGINT NOT NULL,
    session_token VARCHAR(255) UNIQUE NOT NULL,
    device_info VARCHAR(500),                  -- 设备信息
    ip_address VARCHAR(50),                    -- IP 地址
    last_active_at TIMESTAMP,                  -- 最后活跃时间
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (user_id) REFERENCES app_user.users(id)
);

-- 索引
CREATE INDEX idx_user_sessions_user_id ON app_user.user_sessions(user_id);
CREATE INDEX idx_user_sessions_token ON app_user.user_sessions(session_token);
```

---

## 八、安全性设计

### 8.1 密码加密

使用 **BCrypt** 算法：
```java
public class PasswordUtil {
    private static final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
    
    public static String encode(String rawPassword) {
        return encoder.encode(rawPassword);
    }
    
    public static boolean matches(String rawPassword, String encodedPassword) {
        return encoder.matches(rawPassword, encodedPassword);
    }
}
```

### 8.2 Token 安全

1. **使用 HTTPS**：生产环境必须使用 HTTPS
2. **Token 过期时间**：Access Token 2小时，Refresh Token 7天
3. **Token 刷新机制**：Access Token 过期前 5 分钟自动刷新
4. **Token 黑名单**：登出时将 Token 加入黑名单

### 8.3 防护措施

1. **限流**：登录接口限制每分钟 5 次
2. **验证码**：连续失败 3 次后要求验证码
3. **IP 白名单**：敏感操作限制 IP 访问
4. **审计日志**：记录所有认证操作

---

## 九、实施步骤

### 阶段一：基础认证（1-2天）
1. ✅ 创建 User 实体和 Repository（已完成）
2. 实现 JWT 工具类
3. 实现 AuthService 和 TokenService
4. 实现 AuthController（登录、注册、登出）
5. 实现 AuthenticationFilter

### 阶段二：用户上下文（1天）
1. 实现 UserContext 和 UserContextHolder
2. 在 Filter 中注入用户上下文
3. 在 Agent 模块中集成用户上下文

### 阶段三：前端集成（1-2天）
1. 创建登录页面
2. 实现 Axios 拦截器
3. 实现路由守卫
4. 实现用户信息展示

### 阶段四：优化增强（可选）
1. Token 刷新机制
2. 多设备管理
3. 第三方登录（OAuth2）
4. 权限控制（RBAC）

---

## 十、总结

### 核心设计思想

1. **轻量级**：不引入 Spring Security，使用简单的 JWT + Filter
2. **非侵入**：其他模块可选择性依赖用户信息
3. **响应式**：完全兼容 WebFlux 架构
4. **渐进式**：从简单认证开始，逐步扩展

### 优势

- ✅ 实现简单，易于理解和维护
- ✅ 性能开销小，适合响应式架构
- ✅ 灵活性高，支持匿名和认证两种模式
- ✅ 扩展性好，未来可平滑升级到 Spring Security

### 注意事项

1. **生产环境必须使用 HTTPS**
2. **Token 密钥必须保密**
3. **定期清理过期 Token**
4. **做好日志审计**

---

## 附录：参考代码

### A. JwtUtil 完整实现

```java
@Component
public class JwtUtil {
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.access-token-expiration:7200}") // 2小时
    private long accessTokenExpiration;
    
    @Value("${jwt.refresh-token-expiration:604800}") // 7天
    private long refreshTokenExpiration;
    
    public String generateAccessToken(UserContext user) {
        return generateToken(user, accessTokenExpiration);
    }
    
    public String generateRefreshToken(UserContext user) {
        return generateToken(user, refreshTokenExpiration);
    }
    
    private String generateToken(UserContext user, long expiration) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expiration * 1000);
        
        return Jwts.builder()
            .setSubject(user.getExternalId())
            .claim("userId", user.getUserId())
            .claim("nickname", user.getNickname())
            .setIssuedAt(now)
            .setExpiration(expiryDate)
            .signWith(SignatureAlgorithm.HS256, secret)
            .compact();
    }
    
    public UserContext parseToken(String token) {
        Claims claims = Jwts.parser()
            .setSigningKey(secret)
            .parseClaimsJws(token)
            .getBody();
        
        return UserContext.builder()
            .userId(claims.get("userId", Long.class))
            .externalId(claims.getSubject())
            .nickname(claims.get("nickname", String.class))
            .build();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

### B. AuthenticationFilter 完整实现

```java
@Component
public class AuthenticationFilter implements WebFilter {
    
    private final JwtUtil jwtUtil;
    
    public AuthenticationFilter(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
    }
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String path = exchange.getRequest().getPath().value();
        
        // 公开接口，跳过认证
        if (isPublicPath(path)) {
            return chain.filter(exchange);
        }
        
        // 提取 Token
        String token = extractToken(exchange.getRequest());
        
        if (token == null || !jwtUtil.validateToken(token)) {
            // Token 无效，但允许匿名访问
            return chain.filter(exchange);
        }
        
        // 解析用户信息
        UserContext user = jwtUtil.parseToken(token);
        
        // 将用户信息注入到 Reactor Context
        return chain.filter(exchange)
            .contextWrite(ctx -> UserContextHolder.setUser(ctx, user));
    }
    
    private String extractToken(ServerHttpRequest request) {
        String bearerToken = request.getHeaders().getFirst("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private boolean isPublicPath(String path) {
        return path.startsWith("/api/auth/") 
            || path.startsWith("/api/public/")
            || path.equals("/");
    }
}
```

